--[[ API calls:
	Go( [ { x, z, y [,f] } ], [isRelative], [,style]).
		EXAMPLE: Lets say we are at coordinates X=2, Z=-3, Y=4 and if we want to go to X=0,Z=0,Y=0 then all the following will do.
			Nav.Go()
			Nav.Go({0,0,0})
			Nav.Go({0,0,0,1})
			Nav.Go({0,0,0},false,"Normal")
			Nav.Go({-2,3,-4},true,"Normal")
			pos = {x=0, z=0, y=0}; Nav.Go(pos)
		INPUT:
			table { num x, num z, num y [,num f]} : target position and face. If table is nil then default is current position and undefined face. Returns nil if X or Z or Y is nil. F are:
				0: North/X+
				1: East/Z+
				2: South/X-
				3: West/Z-
				else Undefined
			num isRelative : defines if coords are given in absolute or relative. 
				Nil|false|0: Absolute
				true|1: Relative
				2+: Relative to facing direction
			string style : defines different styles how to move around, mostly pathfinding function.
				Default: use "Normal"
				"Normal": combination of "Careful" and "DigCareful" - prefers not to dig but digs if very needed. Recommended for most purposes.
				"Careful": move carefully (recalculate path if block is in a way, doesn't destroy blocks), good for moving inside a base, but inefficient.
				"Dig": move and destroy blocks if one is in a way except if tagged "Use with caution, may destroy other turtles! Use "DigCareful"
				"DigCareful": like "Dig" but returns if there is a turtle in 2sq in front.
				"Explore": move carefully AND check sides if they are unexplored. Good for mapping, but slow.
				"SurfaceExplore": like "Exlore" but ignores Y coordinate and moves on surface, ignoring openings 3+sq deep and 1-2sq wide.
				else use Default
		OUTPUT: 
			Returns true if succeeded, false if not.
	Nav.TurnRight()
		INPUT: nothing
		OUTPUT: nothing
	Nav.TurnLeft()
		INPUT: nothing
		OUTPUT: nothing
	Nav.TurnAround()
		INPUT: nothing
		OUTPUT: nothing
	Nav.GetPos([string switchXZYF])
		INPUT: 
			string switchXZYF: any of the following values "x", "X", "z", "Z", "y", "Y", "f", "F"
		OUTPUT: 
			Default: table {x, z, y, f}, where XZY is absolute coordinates and f is facing direction (0 to 3)
			if switchXZYF: num returnXZYF, a numeric value depending on input string
--]]

local Pos = {} --
Pos.x = 0 -- North
Pos.z = 0 -- East
Pos.y = 0 -- Height
Pos.f = 0 -- Facing direction, modulus of 4 // 0,1,2,3 = North, East, South, West
local Map = {} -- Id={nil=unexplored,false=air,####=Block}, Updated=server's time, Tag={nil,true if tagged by special events}
GetPath = function(tx, tz, ty)  
--[[ DISCLAIMER.
This code (May 04, 2014) is written by Akuukis 
	who based on code (Sep 21, 2006) by Altair
		who ported and upgraded code of LMelior
--]]
--[[ PRE.
Map[][][] is a 3d infinite array (.Id, .Updated, .Evade)
Pos.x is the player's current x or North
Z is the player's current z or East
Pos.y is the player's current y or Height (not yet implemented)
tx is the target x
tz is the target z
ty is the target y (not yet implemented)
style is the preference (not yet implemented)

Note. all the x and z are the x and z to be used in the table.
By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the z can be 1 or 2.
--]]
--[[ POST.
path is a list with all the x and y coords of the nodes of the path to the target.
OR nil if closedlist==nil
--]]
if ty == nil then ty = 0 end
Logger.Debug("Nav.GetPath(%s, %s)\n",tx,tz,ty)
local tempG=0
local tempH=math.abs(Pos.x-tx)+math.abs(Pos.y-tz)						-- Manhattan's method
local closedlist={}																					-- Initialize table to store checked gridsquares
local openlist={}																						-- Initialize table to store possible moves
openlist[1]={x=Pos.x, z=Pos.z, g=0, h=tempH, f=0+tempH ,par=1}	-- Make starting point in list
local curbase={}																						-- Current square from which to check possible moves
local basis=1																								-- Index of current base
local openk=1																								-- Openlist counter
local closedk=0																							-- Closedlist counter
ExploreMap(tx,tz,ty)
Logger.Debug("Nav.GetPath() CurbaseXZ. ")
while openk>0  and table.maxn(closedlist)<500 do   -- Growing loop
	--Logger.Check("")
	if Map[tx][tz][ty].Id then if Map[tx][tz][ty].Id > 0 then return nil end end
	
	-- Get the lowest f of the openlist
	local lowestF=openlist[openk].f
	basis=openk
	for i=openk,1,-1 do
		if openlist[i].f<lowestF then
			lowestF=openlist[i].f
			basis=i
			end
		end

	closedk=closedk+1
	table.insert(closedlist,closedk,openlist[basis]) --Inserts element openlist[basis] at position closedk in table closedlist, 		shifting up other elements to open space, if necessary. // HERE. inserts at the end. 

	curbase=closedlist[closedk]				 -- define current base from which to grow list
	curbase.y=0
	Logger.Debug("(%s,%s@%s/%s) ",curbase.x, curbase.z,closedk,openk)
	
	local NorthOK=true
	local SouthOK=true           				 -- Booleans defining if they're OK to add
	local EastOK=true             				 -- (must be reset for each while loop)
	local WestOK=true

	-- If it IS on the map, check map for obstacles
	--(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
	local suc=true
	local id=0
	suc,id = pcall(function() if Map[curbase.x+1][curbase.z][curbase.y].Id>0 then return 1 else return 0 end end)
	if suc~=true then NorthOK = true elseif id == 0 then NorthOK = true else NorthOK = false; Logger.Debug("North obstacle") end
	suc,id = pcall(function() if Map[curbase.x][curbase.z+1][curbase.y].Id>0 then return 1 else return 0 end end)
	if suc~=true then EastOK = true elseif id == 0 then EastOK = true else EastOK = false; Logger.Debug("East obstacle") end
	suc,id = pcall(function() if Map[curbase.x-1][curbase.z][curbase.y].Id>0 then return 1 else return 0 end end)
	if suc~=true then SouthOK = true elseif id == 0 then SouthOK = true else SouthOK = false; Logger.Debug("South obstacle") end
	suc,id = pcall(function() if Map[curbase.x][curbase.z-1][curbase.y].Id>0 then return 1 else return 0 end end)    
	if suc~=true then WestOK = true elseif id == 0 then WestOK = true else WestOK = false; Logger.Debug("West obstacle") end    
			
	-- Look through closedlist
	if closedk>0 then
		for i=1,closedk do
			if (closedlist[i].x==curbase.x+1 and closedlist[i].z==curbase.z) then NorthOK=false end
			if (closedlist[i].x==curbase.x-1 and closedlist[i].z==curbase.z) then SouthOK=false end
			if (closedlist[i].x==curbase.x and closedlist[i].z==curbase.z+1) then EastOK=false  end
			if (closedlist[i].x==curbase.x and closedlist[i].z==curbase.z-1) then WestOK=false  end
		end
	end
	
	-- Check if next points are on the map and within moving distance
	--[[ Akuukis. Map is infinite
	if curbase.x+1>xsize then
		NorthOK=false
	end
	if curbase.x-1<1 then
		SouthOK=false
	end
	if curbase.z+1>ysize then
		EastOK=false
	end
	if curbase.z-1<1 then
		WestOK=false
	end
	--]]


	--[[
	if Nav.Map[curbase.x+1][curbase.z].Id~=false then NorthOK=false end
	if Nav.Map[curbase.x][curbase.z+1].Id~=false then EastOK=false  end
	if Nav.Map[curbase.x-1][curbase.z].Id~=false then SouthOK=false end
	if Nav.Map[curbase.x][curbase.z-1].Id~=false then WestOK=false  end
	--]]
	
	-- check if the move from the current base is shorter then from the former parent
	tempG=curbase.g+1
	for i=1,openk do
		if NorthOK and openlist[i].x==curbase.x+1 and openlist[i].z==curbase.z and openlist[i].g>tempG then
			tempH=math.abs((curbase.x+1)-tx)+math.abs(curbase.z-tz)
			table.remove(openlist,i)
			table.insert(openlist,i,{x=curbase.x+1, z=curbase.z, g=tempG, h=tempH, f=tempG+tempH, par=closedk})
			NorthOK=false
			end
	
		if SouthOK and openlist[i].x==curbase.x-1 and openlist[i].z==curbase.z and openlist[i].g>tempG then
			tempH=math.abs((curbase.x-1)-tx)+math.abs(curbase.z-tz)
			table.remove(openlist,i)
			table.insert(openlist,i,{x=curbase.x-1, z=curbase.z, g=tempG, h=tempH, f=tempG+tempH, par=closedk})
			SouthOK=false
			end

		if EastOK and openlist[i].x==curbase.x and openlist[i].z==curbase.z+1 and openlist[i].g>tempG then
			tempH=math.abs((curbase.x)-tx)+math.abs(curbase.z+1-tz)
			table.remove(openlist,i)
			table.insert(openlist,i,{x=curbase.x, z=curbase.z+1, g=tempG, h=tempH, f=tempG+tempH, par=closedk})
			EastOK=false
			end

		if WestOK and openlist[i].x==curbase.x and openlist[i].z==curbase.z-1 and openlist[i].g>tempG then
			tempH=math.abs((curbase.x)-tx)+math.abs(curbase.z-1-tz)
			table.remove(openlist,i)
			table.insert(openlist,i,{x=curbase.x, z=curbase.z-1, g=tempG, h=tempH, f=tempG+tempH, par=closedk})
			WestOK=false
			end
		end

	-- Add points to openlist
	-- Add point to the North of current base point
	if NorthOK then
		openk=openk+1
		tempH=math.abs((curbase.x+1)-tx)+math.abs(curbase.z-tz)
		table.insert(openlist,openk,{x=curbase.x+1, z=curbase.z, g=tempG, h=tempH, f=tempG+tempH, par=closedk})
		end

	-- Add point to the South of current base point
	if SouthOK then
		openk=openk+1
		tempH=math.abs((curbase.x-1)-tx)+math.abs(curbase.z-tz)
		table.insert(openlist,openk,{x=curbase.x-1, z=curbase.z, g=tempG, h=tempH, f=tempG+tempH, par=closedk})
		end

	-- Add point to the East of current base point
	if EastOK then
		openk=openk+1
		tempH=math.abs(curbase.x-tx)+math.abs((curbase.z+1)-tz)
		table.insert(openlist,openk,{x=curbase.x, z=curbase.z+1, g=tempG, h=tempH, f=tempG+tempH, par=closedk})
		end

	-- Add point to the West of current base point
	if WestOK then
		openk=openk+1
		tempH=math.abs(curbase.x-tx)+math.abs((curbase.z-1)-tz)
		table.insert(openlist,openk,{x=curbase.x, z=curbase.z-1, g=tempG, h=tempH, f=tempG+tempH, par=closedk})
		end

	table.remove(openlist,basis)
	openk=openk-1
	
	if closedlist[closedk].x==tx and closedlist[closedk].z==tz then
		Logger.Debug("\n")
		Logger.Debug("Nav.GetPath() Found the path! Openlist. %s, Closedlist. %s, Steps. ",table.maxn(openlist),table.maxn(closedlist))
		-- Change Closed list into a list of XZ coordinates starting with player
		local path={} 
		local pathIndex={}
		local last=table.maxn(closedlist)
		table.insert(pathIndex,1,last) 
		local i=1 -- we will include starting position into a table, otherwise 1
		while pathIndex[i]>1 do i=i+1; table.insert(pathIndex,i,closedlist[pathIndex[i-1]].par); end
		Logger.Debug("%s\n", i)
		Logger.Debug("Nav.GetPath() Path. ")
		for i=table.maxn(pathIndex),1,-1 do table.insert(path,{x=closedlist[pathIndex[i]].x, z=closedlist[pathIndex[i]].z}); Logger.Debug("%s(%s,%s)", last, path[table.maxn(pathIndex)-i+1].x, path[table.maxn(pathIndex)-i+1].z) end
		closedlist=nil
		
		-- Change list of XZ coordinates into a list of directions
		Logger.Debug("\n")      
		Logger.Debug("Nav.GetPath() FPath. ")
		local fpath={}
		for i=1,table.maxn(path)-1,1 do 
			if path[i+1].x > path[i].x then fpath[i]=0 end -- North
			if path[i+1].z > path[i].z then fpath[i]=1 end -- East
			if path[i+1].x < path[i].x then fpath[i]=2 end -- South
			if path[i+1].z < path[i].z then fpath[i]=3 end -- West
			Logger.Debug("%s, ", fpath[i])
			end
		Logger.Debug("\n")
		return fpath
		end
	end

return nil
end
Go = function(tx,tz,tries,style)
	if tx == nil then tx = Pos.x else tx=tonumber(tx) end
	if tz == nil then tz = Pos.z else tz=tonumber(tz) end
	if ty == nil then ty = Pos.y else ty=tonumber(ty) end
	Logger.Debug("Nav.GoPath(%s,%s,%s)\n", tx, tz, tries)
	if tries == nil then tries = 32 end
	local j=1
	repeat
		if (Pos.x==tx and Pos.z==tz) then return true else tries=tries-1 end
		Logger.Debug("Nav.GoPath() @(%s,%s,%s) /%s\n",Pos.x,Pos.z,Pos.y,tries)
		local fpath = GetPath(tx,tz)
		if fpath == nil then 
			Logger.Debug("Nav.GoPath() FPath=nil!")
			UpdateMap()
			TurnRight()
			else 
			j=0
			repeat
				j=j+1 
				Logger.Debug("Nav.GoPath() @(%s,%s,%s), Moving %s/%s ...\n", Pos.x,Pos.z,Pos.y,j,table.maxn(fpath))
				until not (Move(fpath[j]) and j<table.maxn(fpath))
			end
		until tries<0
	Logger.Debug("Nav.GoPath() Out-of-UNTIL! /%s",tries)
	return false
	end
Move = function(dir) -- dir{0=North|1=East|2=South|3=West|4=up|5=down}, returns true if succeeded
	local success = 0
	Logger.Debug("Nav.Move(%s)\n", dir)
	Utils.Refuel()
	if dir==4 then               -- Up
		success = turtle.up()
		elseif dir==5 then         -- Down
		success = turtle.down()
		elseif dir==Pos.f-1 or dir==Pos.f+3 then -- Left
		TurnLeft()
		success = turtle.forward()
		elseif dir==Pos.f-2 or dir==Pos.f+2 then -- Right
		TurnAround()
		success = turtle.forward()
		elseif dir==Pos.f-3 or dir==Pos.f+1 then -- 180
		TurnRight()
		success = turtle.forward()
		else                       -- Forward
		success = turtle.forward()
		end
	if success then
		UpdateCoord(dir)
		UpdateMap(dir)
		--Logger.Debug("Nav.Move() Return true\n")
		return true
		else
		UpdateMap()
		Logger.Debug("Nav.Move() Return false\n")
		return false
		end
	end
TurnRight = function(self)
	turtle.turnRight()
	Logger.Debug("Nav.TurnRight() Nav.Pos.f. %s => ",Pos.f)
	Pos.f=(Pos.f+1)%4
	Logger.Debug("%s\n",Pos.f)
	UpdateMap()
	end
TurnLeft = function(self)
	turtle.turnLeft()
	Logger.Debug("Nav.TurnLeft() Nav.Pos.f. %s => ",Pos.f)
	Pos.f=(Pos.f+3)%4
	Logger.Debug("%s\n",Pos.f)
	UpdateMap()    
	end
TurnAround = function(self)
	if 1==math.random(0,1) then
		TurnRight()
		TurnRight()
		else
		TurnLeft()
		TurnLeft()
		end
	end
DirToCoord = function(dir) -- returns x,z,y
	--Logger.Debug("Nav.DirToCoord(%s)\n", dir)
	if dir==0 then return Pos.x+1, Pos.z, Pos.y end
	if dir==1 then return Pos.x, Pos.z+1, Pos.y end
	if dir==2 then return Pos.x-1, Pos.z, Pos.y end
	if dir==3 then return Pos.x, Pos.z-1, Pos.y end
	if dir==4 then return Pos.x, Pos.z, Pos.y+1 end
	if dir==5 then return Pos.x, Pos.z, Pos.y-1 end
	Logger.Debug("Nav.DirToCoord. ERROR\n")
	end    
UpdateCoord = function(dir)
		--Logger.Debug("Nav.UpdateCoord(%s)\n",dir)
		Pos.x,Pos.z,Pos.y = DirToCoord(dir)
	end
UpdateMap = function(location,value) -- location{nil|dir|XZY), value{0=air,1=unknown block,1+=known block}  
	--Logger.Debug("Nav.UpdateMap(%s,%s)\n",location,value)
	local x,z,y
	if type(location)=="nil" then
		x,z,y = DirToCoord(Pos.f)
		--Logger.Debug("Nav.UpdateMap. (nil) %s, %s, %s\n",x,z,y)
		ExploreMap(x,z,y)      
		Map[x][z][y].Updated = os.time()
		if turtle.detect() then Map[x][z][y].Id = 1 else Map[x][z][y].Id = 0 end
		elseif type(location)=="number" then
		x,z,y = DirToCoord(Pos.f)
		--Logger.Debug("Nav.UpdateMap. (number) %s, %s, %s\n",x,z,y)
		ExploreMap(x,z,y)
		Map[x][z][y].Updated = os.time()
		if turtle.detect() then Map[x][z][y].Id = 1 else Map[x][z][y].Id = 0 end
		if location~=5 then
			x,z,y = DirToCoord(4)
			ExploreMap(x,z,y)
			Map[x][z][y].Updated = os.time()
			if turtle.detectUp() then Map[x][z][y].Id = 1 else Map[x][z][y].Id = 0 end
			end
		if location~=4 then
			x,z,y = DirToCoord(5)
			ExploreMap(x,z,y)
			Map[x][z][y].Updated = os.time()
			if turtle.detectDown() then Map[x][z][y].Id = 1 else Map[x][z][y].Id = 0 end
			end      
		elseif type(location)=="table" then
		--Logger.Debug("Nav.UpdateMap. (table) %s, %s, %s\n",x,z,y)
		x,z,y = location[1] or location.x, location[2] or location.z, location[3] or location.y
		if value == nil then value = 1 end
		ExploreMap(x,z,y)
		Map[x][z][y].Updated = os.time()
		Map[x][z][y].Id = value
		end
	end
ExploreMap = function(x,z,y)
	--Logger.Debug("ExploreMap(%s,%s,%s)\n", x,z,y)
	if Map[x] == nil then Map[x]={} end
	if Map[x][z] == nil then Map[x][z]={} end
	if Map[x][z][y] == nil then Map[x][z][y]={} end
	end
GetPos = function(Switch)
	Pos.f = Pos.f%4
	if Switch == nil or type(Switch) ~= "string" then return Pos
		elseif Switch == "x" or Switch == "X" then return Pos.x
		elseif Switch == "z" or Switch == "Z" then return Pos.z
		elseif Switch == "y" or Switch == "Y" then return Pos.y
		elseif Switch == "f" or Switch == "F" then return Pos.f
		end
	return nil
	end
Test = function(self)
	return 1
	end