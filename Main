path = select(1,...)
if path == nil then path = "" end

--                 "Main" -- (in WIP - mainly debugging) Provides ongoing process, handles errors and updates APIs on the fly
os.loadAPI(path .. "Init") -- Provides set-up for turtle that has just been turned on
os.loadAPI(path .. "Comm") -- Provides sending & listening to info between turtles
os.loadAPI(path .. "Utils") -- Provides Self-monitoring, reacting & a collection of random tasks
os.loadAPI(path .. "Resm") -- Provides resource management. Counts and prices resources in Suppy and Demand
os.loadAPI(path .. "Logic") -- Provides decision making, weights alternatives and picks a Job to do
os.loadAPI(path .. "Nav") -- Provides pathfinding, moving & mapping
os.loadAPI(path .. "Jobs") -- Provides a collection of instructions
os.loadAPI(path .. "Logger") -- Filters info and parses it to Stats, Rui, Gui, Hud (not vital but very neccessary)
os.loadAPI(path .. "Stats") -- Gathers and aggregates data for analysis, improvement and fun
os.loadAPI(path .. "Rui") -- Remote (or Rednet) user interface (Player interface, not vital)
os.loadAPI(path .. "Gui") -- Graphical user interface (Player interface, not vital)
os.loadAPI(path .. "Hud") -- Heads-Up display (Player interface, not vital)

local n = 1
local Threads = {}
local Filter = {}
local CoData = {}

--[[ coroutine.resume Returns:
	1. boolean Ok: true if its ok, false if coroutine error()
	2. string Filter/ErrorMsg/: if Ok=true Filter is event name (may be nil=no filter), if Ok=false then ErrorMsg is error message.
	[3. function Call: if coroutine wants to start another coroutine it will return Call
	 4. boolean noYield: true if coroutine wants to continue without waiting to other coroutines
	 [5. table Args: Args to be passed to Call ] ]
--]]

local n = #Threads
local tFilters = {}
local Args = {}
local eventData = {}

-- The First coroutine
Threads[n] = coroutine.create(Init.Start)

-- Run until no coroutines left (won't happen normally)
while n > 0 do 

	-- Cycle through active coroutines. Repeat twice if coroutine returned NoYield (see "if noYield then i = i - 1 end")
	for i=1,n do 
	
		-- Clean up the table of coroutines - if there's a gap, shift others up.
		if Threads[i] == nil or coroutine.status( Threads[i] ) == "dead" then
			for j=i,n-1 do Threads[j] = Threads[j+1] end
			n = n - 1
			i = i - 1
			
		-- Resume one coroutine
		else
			local Ok, Call, noYield, Arguments
			Arguments = eventData
			if Args[Threads[i]] then -- If the coroutine is a new one, call it with original arguments if it has any, otherwise call with eventData
				Arguments = Args[Threads[i]]
				Args[Threads[i]] = nil
			end
			if Args[Threads[i]] or tFilters[Threads[i]] == nil or tFilters[Threads[i]] == Arguments[1] then -- Check for filters
				Ok, tFilters[Threads[i]], Call, noYield, Args[Threads[i]] = coroutine.resume( Threads[i], unpack(Arguments) ) -- Call a coroutine
				if not Ok then Logger.Error("Coroutine failed! %s", tFilters[Threads[i]] ) end -- Inform if coroutine failed
				elseif Call then -- prepare a new coroutine
					n = n + 1
					Threads[n] = coroutine.create(Call)
					Logger.Check("NewThr: %s\n",Threads[n])
					if noYield then i = i - 1 end
				end
		end
	end
	eventData = { os.pullEventRaw() } -- after a cycle call eventData
end
Logger.Check("Out-of-coroutines!")
os.shutdown()



--[[ Redundant
-- The First coroutine
Threads[n] = coroutine.create(Init.Start)

-- Run until no coroutines left (won't happen normally)
while n > 0 do

	-- Cycle through active coroutines. Repeat twice if coroutine returned NoYield (see "if CoData[4] then i = i - 1 end")
	for i=1,n do
	
		-- Clean up the table of coroutines - if there's a gap, shift others up.
		if Threads[i] == nil then
			Logger.Check("Del %s/%s\n",i,n)
			for j=i,n-1 do Threads[j] = Threads[j+1]; args[j] = args[j+1] end
			n = n - 1
			i = i - 1
			
		else
			Logger.Check("Run %s/%s\n",i,n)
			Logger.Check("Thr %s\n",Threads[i])
			CoData = { coroutine.resume(Threads[i], args[i]) }
			if type(CoData[1]) == "string" then coroutine.se end
			Logger.Check("CoData: %s,%s,%s,%s\n",unpack(CoData))
			if not CoData[0] then Logger.Error("Coroutine failed! %s", CoData[1]) end
			if coroutine.status(Threads[i]) == "dead" then Threads[i] = nil	end
			if CoData[2] ~= nil then
				n = n + 1
				Threads[n] = coroutine.create(CoData[2])
			Logger.Check("NewThr: %s\n",Threads[n])
			end
			if CoData[4] then i = i - 1 end
		end
	end
	args = os.pullEvent()
	
	
end
Logger.Check("Out-of-coroutines!")
os.shutdown()
--]]